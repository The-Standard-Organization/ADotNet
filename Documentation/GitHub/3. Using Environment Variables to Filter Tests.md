# 3. Using Environment Variables to Filter Tests

Integration tests are essential for ensuring the reliability and functionality of software systems. 
They are responsible for validating the interaction between different components and external dependencies, 
which helps in identifying potential issues and improving the overall quality of an application. 
However, there are situations where developers may choose not to run integration tests continuously and instead 
opt for a more selective approach. This decision can be influenced by various factors, such as the cost implications 
of accessing external resources.

In this article will provide guidance on using conditional logic in your GitHub Action to set an environment variable 
that can be used to determine which tests should be included or excluded during the testing process. This approach allows 
developers to have fine-grained control over the execution of integration tests and facilitates efficient testing workflows.


## 3.1. How to conditionally set an environment variable in a GitHub Action
For our tagging and release process we check for the following conditions:
- The pull request has a title that starts with the string "RELEASES:" and a `label` with the string "RELEASES".
OR
- The push request has a title that starts with the string "RELEASES:" and a `tag` with the string "RELEASES".

We will use this same conditions to set an environment variable that can be used to determine which tests should 
be included or excluded during the testing process.

Lets have a look at how this can be achieved by adding the following code:

```csharp
var githubPipeline = new GithubPipeline
{
    . . .

    EnvironmentVariables = new Dictionary<string, string>
    {
        { "YOUR_APPLICATION_NAME_IS_RELEASE_CANDIDATE", EnvironmentVariables.IsGitHubReleaseCandidate() }
    },

    . . .
};
```

**yaml output for the above code**
```yaml
env:
  IS_RELEASE_CANDIDATE: >-
    ${{
      (
        github.event_name == 'pull_request' &&
        startsWith(github.event.pull_request.title, 'RELEASES:') &&
        contains(github.event.pull_request.labels.*.name, 'RELEASES')
      )
      ||
      (
        github.event_name == 'push' &&
        startsWith(github.event.head_commit.message, 'RELEASES:') &&
        startsWith(github.ref_name, 'RELEASE')
      )
    }}
```

This GitHub Action defines an environment variable called "IS_RELEASE_CANDIDATE" and assigns it a 
value based on the conditions specified within the multi-line YAML block. The value is determined 
by evaluating a complex logical expression that incorporates various properties and events from the GitHub context.

Let's break down the logical expression to understand its components and conditions:

1. **github.event_name == 'pull_request'**: This condition checks if the event triggering the GitHub Action 
is a pull request event.

2. **startsWith(github.event.pull_request.title, 'RELEASES:')**: This condition checks if the title of the pull 
request starts with the string "RELEASES:".

3. **contains(github.event.pull_request.labels.*.name, 'RELEASES')**: This condition checks if any of the labels 
associated with the pull request contain the string "RELEASES".

The above three conditions are combined with the logical AND operator (&&) to form the first part of the expression:

```yaml
(
  github.event_name == 'pull_request' &&
  startsWith(github.event.pull_request.title, 'RELEASES:') &&
  contains(github.event.pull_request.labels.*.name, 'RELEASES')
)
```

4. **github.event_name == 'push'**: This condition checks if the event triggering the GitHub Action is a push event.

5. **startsWith(github.event.head_commit.message, 'RELEASES:')**: This condition checks if the commit message of the 
latest commit in the push starts with the string "RELEASES:".

6. **startsWith(github.ref_name, 'RELEASE')**: This condition checks if the name of the branch or tag being pushed 
starts with the string "RELEASE".

The above three conditions are combined with the logical AND operator (&&) to form the second part of the expression:

```yaml
(
  github.event_name == 'push' &&
  startsWith(github.event.head_commit.message, 'RELEASES:') &&
  startsWith(github.ref_name, 'RELEASE')
)
```

Finally, the two parts of the expression are combined with the logical OR operator (||) to form the complete expression:

```yaml
(
  (
    github.event_name == 'pull_request' &&
    startsWith(github.event.pull_request.title, 'RELEASES:') &&
    contains(github.event.pull_request.labels.*.name, 'RELEASES')
  )
  ||
  (
    github.event_name == 'push' &&
    startsWith(github.event.head_commit.message, 'RELEASES:') &&
    startsWith(github.ref_name, 'RELEASE')
  )
)
```

If this complete expression evaluates to true, the value of the "IS_RELEASE_CANDIDATE" environment variable will 
be set to true, otherwise it will be set to false. The value is determined dynamically based on the event context 
and its properties.


## 3.2. How to dynamically filter tests based on the value of an environment variable

Now that we have an environment variable that indicates whether the current event is a release candidate, 
we can dynamically filter tests based on its value. This can be achieved by adding the following code in your test project:

1. Create a new class that implements the ITestCaseDiscoverer interface. This class will be responsible for filtering out 
the tests based on the environment variable value.

```csharp
using System.Collections.Generic;
using Microsoft.Extensions.Configuration;
using Xunit.Abstractions;
using Xunit.Sdk;

public class ReleaseCandidateTestCaseDiscoverer : IXunitTestCaseDiscoverer
{
    private readonly IMessageSink diagnosticMessageSink;
    private readonly IConfiguration configuration;

    public ReleaseCandidateTestCaseDiscoverer(IMessageSink diagnosticMessageSink)
    {
        this.diagnosticMessageSink = diagnosticMessageSink;

        var configurationBuilder = new ConfigurationBuilder()
            .AddJsonFile("appsettings.json", optional: true, reloadOnChange: true)
            .AddEnvironmentVariables("YOUR_APPLICATION_NAME_");

        this.configuration = configurationBuilder.Build();
    }

    public IEnumerable<IXunitTestCase> Discover(
        ITestFrameworkDiscoveryOptions discoveryOptions, 
        ITestMethod testMethod, 
        IAttributeInfo factAttribute)
    {
        var isReleaseCandidate = configuration.GetValue<bool>("IS_RELEASE_CANDIDATE");

        if (isReleaseCandidate)
        {
            yield return new XunitTestCase(
                diagnosticMessageSink,
                defaultMethodDisplay: discoveryOptions.MethodDisplayOrDefault(),
                defaultMethodDisplayOptions: discoveryOptions.MethodDisplayOptionsOrDefault(),
                testMethod);
        }
    }
}
```

In the constructor we are creating a new instance of the ConfigurationBuilder class and adding two configuration providers.
This will allow us to read the value of the "IS_RELEASE_CANDIDATE" variable from the configuration.  
As you can see from the code we have added support for reading the value from the appsettings.json file 
and from the environment variables.

What makes this super useful is that we can in our local development environment set the value of the "IS_RELEASE_CANDIDATE"
if we want to test the release candidate tests locally. This can be achieved by adding the following code to the 
appsettings.json file:

```json
{
  "IS_RELEASE_CANDIDATE": false
}
```
(If you had to create a new appsettings.json file, make sure to set the "Copy to Output Directory" property to "Copy if newer")

The second thing to note is that the environment variable name is prefixed with the name of the application.  
We do this to avoid conflicts with other applications that might be running on the same machine with the same.  
For example, you prefer not to use appsettings.json and instead use environment variables to configure your application.
You can then create an environment variable for `APPLICATION_A_IS_RELEASE_CANDIDATE` and another one 
for `APPLICATION_B_IS_RELEASE_CANDIDATE`. Based on the prefix, the correct environment variable will then be read.

The other nice thing is the hierarchical nature of the configuration.  Environment variables take precedence 
over the appsettings.json file.   This means that if you have an environment variable with the same name as a 
setting in appsettings.json, The final result will be the value of the environment variable.

2. Add a custom attribute to your test methods to indicate that they should be filtered based on the environment variable value.

```csharp
using System;
using Xunit;

[AttributeUsage(AttributeTargets.Method, AllowMultiple = false)]
[XunitTestCaseDiscoverer("YourNamespace.ReleaseCandidateTestCaseDiscoverer", "YourAssemblyName")]
public class ReleaseCandidateFactAttribute : FactAttribute { }

```
(Replace "YourNamespace" and "YourAssemblyName" with the correct values for your project)

3. Now, you can use the ReleaseCandidateFactAttribute on your test methods instead of the regular FactAttribute.

```csharp
public class MyTestClass
{
    [Fact]
    public void MyTestMethod1()
    {
        // Your test code here
        Assert.True(true);
    }

    [ReleaseCandidateFact]
    public void MyTestMethod2()
    {
        // Your test code here
        Assert.True(true);
    }
}
```

4. Lets run the tests locally and see what happens.  Up this this point we have set the value 
of "IS_RELEASE_CANDIDATE" in the appsettings.json file to false.  We have not yet set an environment 
variable, so the resulting value of the "IS_RELEASE_CANDIDATE" variable will be false.  At this point our
expectation is to see a pass for `MyTestMethod1` and a skip for `MyTestMethod2`.
And we can also see this from the test results:

![image](https://github.com/hassanhabib/ADotNet/assets/797750/f7e1edef-1648-42a9-9cc6-0ba6df5395d5)


5. Now lets change the value of the "IS_RELEASE_CANDIDATE" variable to true in the appsettings.json file:

```json
{
  "IS_RELEASE_CANDIDATE": true
}
```

6. Lets run the tests locally and see what happens what happened after we changed this value.  
Our expectation is to see a pass for both tests.
From the test results we can also see this:

![image](https://github.com/hassanhabib/ADotNet/assets/797750/3d1abdbd-d1ca-4c60-94c5-73f4e1b33ef6)


So far so good.  Now lets see what happens when we add an environment variable.

7.In Visual Studio's Package Manager Console, you can set an environment variable using the `Set-Item` 
cmdlet. Here's how you can set the "YOUR_APPLICATION_NAME_IS_RELEASE_CANDIDATE" environment variable:

```powershell
# Set the value of the "IS_RELEASE_CANDIDATE" environment variable
Set-Item -Path Env:IS_RELEASE_CANDIDATE -Value "false"
```

8. At this point we have to close Visual Studio and reopen it.  This is because Visual Studio caches the environment variables 
when it starts.  If you don't close and reopen Visual Studio, the value of the environment variable will not be updated.

9. Open Visual Studio and navigate to the Test Explorer window and run the tests again.  
Our expectation is to see a pass for `MyTestMethod1` and a skip for `MyTestMethod2`.   This is because the value of the
environment variable is false, which will superceded the value in appsettings.json (currently true) and 
cause the ReleaseCandidateTestCaseDiscoverer to skip the test.
We can also see this from the test results:

![image](https://github.com/hassanhabib/ADotNet/assets/797750/f7e1edef-1648-42a9-9cc6-0ba6df5395d5)


10. Now lets change the value of the environment variable to true.  We can 
do this by running the following command in the Package Manager Console:

```powershell
# Set the value of the "IS_RELEASE_CANDIDATE" environment variable
Set-Item -Path Env:IS_RELEASE_CANDIDATE -Value "true"
```

11. We will have to close Visual Studio and reopen it again to refresh the cached environment variables in Visual Studio.

12. Open Visual Studio and navigate to the Test Explorer window and run the tests again.  
Our expectation is to see a pass for both `MyTestMethod1` and `MyTestMethod2`.
We can also see this from the test results:

![image](https://github.com/hassanhabib/ADotNet/assets/797750/3d1abdbd-d1ca-4c60-94c5-73f4e1b33ef6)


13. To test the hierachy, you can now toggle the value of the "IS_RELEASE_CANDIDATE" variable in the appsettings.json file.  
You will notice that this does not affect the test results and that both test methods will still pass even if the value
in the appsettings.json file is false.  This is because the value of the environment variable will supercede the value in
the appsettings.json file.

If you want to remove the environment variable, you can run the following command in the Package Manager Console:
```powershell
# Remove the "IS_RELEASE_CANDIDATE" environment variable
Remove-Item -Path Env:IS_RELEASE_CANDIDATE
```

By using this approach, you don't need to include the conditional logic in every test. Instead, the test discovery 
process filters out the tests based on the environment variable value before running them.

 
